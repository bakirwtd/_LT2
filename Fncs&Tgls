local Funcs = {}
local function GetCFrame(item)
    if item:FindFirstChild("MainCFrame") then
        return item.MainCFrame.Value
    end
    return nil, "Unsupported item."
end

Funcs.MoveStructure = function(X, Y, Z)
    if SelectedItem then
        local name = SelectedItem.ItemName.Value
        local V3 = Vector3.new(X, Y, Z)
        local CFrame, Error = GetCFrame(SelectedItem)
        if not CFrame then
            return Funcs.Msg("Error", Error)
        end
        local newCFrame = CFrame + V3
        local args = {
            [1] = name,
            [2] = newCFrame,
            [3] = Client,
            [5] = SelectedItem,
            [6] = true
        }
        if SelectedItem:FindFirstChild("BlueprintWoodClass") then
            args[4] = SelectedItem.BlueprintWoodClass.Value
        end
        game:GetService("ReplicatedStorage"):WaitForChild("PlaceStructure"):WaitForChild("ClientPlacedStructure")
            :FireServer(unpack(args))
    else
        Funcs.Msg("Error", "Select a structure.")
    end
    SelectedItem = nil
end

Funcs.Marker = function(adornee)
    local hl = Instance.new("BillboardGui", adornee)
    hl.Size = UDim2.fromScale(1, 1)
    hl.AlwaysOnTop = true
    local frame = Instance.new("Frame", hl)
    frame.Size = UDim2.fromScale(1, 1)
    frame.BackgroundColor3 = Color3.new(0, 1, 0)
    frame.BackgroundTransparency = 0.4
    local corner = Instance.new("UICorner", frame)
    corner.CornerRadius = UDim.new(0.3, 0)
    hl.Name = "ITEM_MARKER"
end
Funcs.MarkItem = function(item)
    for _, v in pairs(PModels:GetChildren()) do
        if Funcs.SameItem(item, v) then
            if v:FindFirstChild("Main") then
                Funcs.Marker(v.Main)
            elseif v:FindFirstChild("WoodSection") then
                Funcs.Marker(v.WoodSection)
            else
                warn("Unmarkable Item.")
            end
        end
    end
end
Funcs.ClearMarkers = function()
    for _, v in pairs(PModels:GetDescendants()) do
        if v.Name == "ITEM_MARKER" then
            v:Destroy()
        end
    end
end
Funcs.GetPos = function()
    return Funcs.GetRoot().CFrame.Position
end
Funcs.GetRoot = function()
    return Client.Character.HumanoidRootPart
end
Funcs.Format = function(Number, Digits)
    local formatnum = "1"
    for _ = 1, Digits do
        formatnum = formatnum .. "0"
    end
    formatnum = tonumber(formatnum) or 10
    local FormattedNumber = math.floor(Number * formatnum) / formatnum
    return tonumber(FormattedNumber) or nil
end
Funcs.Ping = function()
    game.ReplicatedStorage.TestPing:InvokeServer()
end
Funcs.GetStore = function(Item, Pos)
    local Stores = {
        WoodRUs = Vector3.new(300.5, 3.1, 53.7),
        FancyFurnishings = Vector3.new(507.1, 3.2, -1761.1),
        BoxedCars = Vector3.new(508.5, 3.1, -1445.3),
        BobsShack = Vector3.new(265.8, 8.4, -2543.6)
    }
    local Cashiers = {
        WoodRUs = Vector3.new(266.3, 3.1, 64.2),
        FancyFurnishings = Vector3.new(482.8, 3.2, -1721.7),
        BoxedCars = Vector3.new(524.3, 3.1, -1460.6),
        BobsShack = Vector3.new(260.9, 8.4, -2548.1)
    }
    local Counters = {
        WoodRUs = Vector3.new(268, 5.1, 67.1),
        FancyFurnishings = Vector3.new(477.4, 5.5, -1722.2),
        BoxedCars = Vector3.new(528.1, 5.5, -1459.8),
        BobsShack = Vector3.new(260.4, 10.4, -2551.7)

    }
    local MaxDist = 60
    for _, v in pairs(Stores) do
        if (Pos - v).Magnitude < MaxDist then
            return tostring(_), Cashiers[_], Counters[_]
        end
    end
    return nil
end
Funcs.ConfirmPurchase = function(Store)
    local args
    if Store == "BobsShack" then
        args = {
            [1] = {
                ["ID"] = 10,
                ["Character"] = workspace:WaitForChild("Stores"):WaitForChild("ShackShop"):WaitForChild("Bob"),
                ["Name"] = "Bob",
                ["Dialog"] = workspace:WaitForChild("Stores"):WaitForChild("ShackShop"):WaitForChild("Bob")
                    :WaitForChild("Dialog")
            },
            [2] = "ConfirmPurchase"
        }
    elseif Store == "WoodRUs" then
        args = {
            [1] = {
                ["ID"] = 7,
                ["Character"] = workspace:WaitForChild("Stores"):WaitForChild("WoodRUs"):WaitForChild("Thom"),
                ["Name"] = "Thom",
                ["Dialog"] = workspace:WaitForChild("Stores"):WaitForChild("WoodRUs"):WaitForChild("Thom"):WaitForChild(
                    "Dialog")
            },
            [2] = "ConfirmPurchase"
        }
    elseif Store == "FancyFurnishings" then
        args = {
            [1] = {
                ["ID"] = 8,
                ["Character"] = workspace:WaitForChild("Stores"):WaitForChild("FurnitureStore"):WaitForChild("Corey"),
                ["Name"] = "Corey",
                ["Dialog"] = workspace:WaitForChild("Stores"):WaitForChild("FurnitureStore"):WaitForChild("Corey")
                    :WaitForChild("Dialog")
            },
            [2] = "ConfirmPurchase"
        }
    elseif Store == "BoxedCars" then
        args = {
            [1] = {
                ["ID"] = 9,
                ["Character"] = workspace:WaitForChild("Stores"):WaitForChild("CarStore"):WaitForChild("Jenny"),
                ["Name"] = "Jenny",
                ["Dialog"] = workspace:WaitForChild("Stores"):WaitForChild("CarStore"):WaitForChild("Jenny")
                    :WaitForChild("Dialog")
            },
            [2] = "ConfirmPurchase"
        }
    elseif Store == "LinksLogic" then
        args = {
            [1] = {
                ["ID"] = 12,
                ["Character"] = workspace:WaitForChild("Stores"):WaitForChild("LogicStore"):WaitForChild("Lincoln"),
                ["Name"] = "Lincoln",
                ["Dialog"] = workspace:WaitForChild("Stores"):WaitForChild("LogicStore"):WaitForChild("Lincoln")
                    :WaitForChild("Dialog")
            },
            [2] = "ConfirmPurchase"
        }
    end
    game:GetService("ReplicatedStorage"):WaitForChild("NPCDialog"):WaitForChild("PlayerChatted"):InvokeServer(unpack(
        args))
end
Funcs.GetNetwork = function(item)
    local starttick = tick()
    if table.find(Tables.Draggables, item.Name) then
        for _ = 1, Numbers.Checks do
            Tables.Remotes.Dragging:FireServer(item.Parent)
            task.wait()
        end
    end
end
Funcs.SizeSawmill = function(Axis, Direction)
    local RemName = "ButtonRemote_" .. Axis .. Direction
    if Objects.SelectedSawMill then
        local rem = Objects.SelectedSawMill:FindFirstChild(RemName)
        if rem then
            Tables.Remotes.Proxy:FireServer(rem)
        end
    end
end
Funcs.GetService = function(Name)
    return game:GetService(Name) or game:FindFirstChild(Name) or nil
end
Funcs.GetAxe = function()
    if Client.Character:FindFirstChildOfClass("Tool") then
        return Client.Character:FindFirstChildOfClass("Tool")
    end
    return nil
end
Funcs.UpdatePosition = function()
    Objects.ControlPart = Funcs.GetRoot()
    Bools.CFrameSpeed = false
    Bools.Flying = false
    Objects.ControlPart.Anchored = false
    Funcs.Msg("Success", "Updated Successfully")
end
Funcs.makebase = function(pos)
    local Event = game:GetService("ReplicatedStorage").PropertyPurchasing.ClientExpandedProperty
    if Funcs.GetPlot(Client) then
        Event:FireServer(Funcs.GetPlot(Client), pos)
    end
end
Funcs.LoopCut = function(section, height)
    local Damage = Funcs.GetDamage(Funcs.GetAxe(), section.Parent.TreeClass.Value)
    local Cut = false
    local CutArguments = {
        sectionId = section.ID.Value,
        faceVector = Vector3.new(0, 0, -1),
        height = height,
        hitPoints = Damage,
        cooldown = 0,
        cuttingClass = "Axe",
        tool = Funcs.GetAxe()
    }
    section:GetPropertyChangedSignal("Size"):Connect(function()
        Cut = true
    end)
    repeat
        game.ReplicatedStorage.Interaction.RemoteProxy:FireServer(section.Parent.CutEvent, CutArguments)
        task.wait()
    until Funcs.GetAxe() == nil or Cut == true
end
Funcs.SpecificLoopCut = function(part)
    repeat
        task.wait()
        Funcs.LoopCut(part, part.Size.Y - Numbers.CutSize)
    until part.Size.Y < Numbers.CutSize
end
Funcs.LandBuildSquare = function(pos)
    local greenpart = Instance.new("Part", game.Workspace)
    greenpart.Anchored = true
    greenpart.CanCollide = false
    greenpart.CFrame = pos
    greenpart.Size = Vector3.new(37, .5, 37)
    local clickdet = Instance.new("ClickDetector", greenpart)
    clickdet.MouseClick:Connect(function()
        Funcs.makebase(pos)
        greenpart:Destroy()
    end)
    task.spawn(function()
        repeat
            wait()
        until not Bools.Building
        greenpart:Destroy()
    end)
end
Funcs.DestroyItem = function(item)
    game.ReplicatedStorage.Interaction.DestroyStructure:FireServer(item)
end
Funcs.GotoPlot = function()
    Funcs.Teleport(Funcs.GetPlot(Client).OriginSquare.Position + Vector3.new(0, 3, 0))
end
Funcs.GetDamage = function(Axe, TreeClass)
    if Axe.ToolTip == "Basic Hatchet" then
        return 0.2
    elseif Axe.ToolTip == "Plain Axe" then
        return 0.55
    elseif Axe.ToolTip == "Steel Axe" then
        return 0.93
    elseif Axe.ToolTip == "Hardened Axe" then
        return 1.45
    elseif Axe.ToolTip == "Silver Axe" then
        return 1.6
    elseif Axe.ToolTip == "Rukiryaxe" then
        return 1.68
    elseif Axe.ToolTip == "Beta Axe of Bosses" then
        return 1.45
    elseif Axe.ToolTip == "Alpha Axe of Testing" then
        return 1.5
    elseif Axe.ToolTip == "Candy Cane Axe" then
        return 0
    elseif Axe.ToolTip == "Johiro" then
        return 1.8
    elseif Axe.ToolTip == "Beesaxe" then
        return 1.4
    elseif Axe.ToolTip == "CHICKEN AXE" then
        return 0.9
    elseif Axe.ToolTip == "Amber Axe" then
        return 3.39
    elseif Axe.ToolTip == "The Many Axe" then
        return 10.2

        -- // Special Axes
    elseif Axe.ToolTip == "Refined Axe" then
        return 12
    elseif Axe.ToolTip == "Cave Axe" then
        if TreeClass == "CaveCrawler" then
            return 7.2
        end
        return 0.4
    elseif Axe.ToolTip == "Fire Axe" then
        if TreeClass == "Volcano" then
            return 6.35
        end
        return 0.6
    elseif Axe.ToolTip == "End Times Axe" then
        if TreeClass ~= "LoneCave" then
            return 1.58
        else
            return 10000000
        end
    elseif Axe.ToolTip == "Gingerbread Axe" then
        if TreeClass == "Walnut" then
            return 8.5
        elseif TreeClass == "Koa" then
            return 11
        else
            return 1.2
        end
    elseif Axe.ToolTip == "Bird Axe" then
        if TreeClass ~= "Volcano" and TreeClass ~= "CaveCrawler" then
            return 0.5
        else
            return 0.4
        end
    elseif Axe.ToolTip == "Frost Axe" then
        if TreeClass ~= "Frost" then
            return 0.36
        else
            return 6
        end
    end
end
Funcs.GetOffsetBottom = function(ray, part)
    if part and part:IsA("BasePart") then
        local partPos = part.Position
        local partSize = part.Size
        local result = workspace:Raycast(ray.Origin, ray.Direction * 1000)

        if result and result.Instance == part then
            local hitPos = result.Position
            local bottomFacePos = partPos - part.CFrame.UpVector * (partSize.Y / 2)

            local offset = (hitPos - bottomFacePos).Magnitude
            return offset
        end
    end
    return 1
end
Funcs.CutTree = function(Tree, ray, part)
    local Damage = Funcs.GetDamage(Funcs.GetAxe(), Tree.TreeClass.Value)
    local Cut = false
    local CutArguments = {
        sectionId = part.ID.Value,
        faceVector = Vector3.new(0, 0, -1),
        height = Funcs.GetOffsetBottom(ray, part),
        hitPoints = Damage,
        cooldown = 0,
        cuttingClass = "Axe",
        tool = Funcs.GetAxe()
    }
    part:GetPropertyChangedSignal("Size"):Connect(function()
        Cut = true
    end)
    repeat
        game.ReplicatedStorage.Interaction.RemoteProxy:FireServer(Tree.CutEvent, CutArguments)
        task.wait()
    until Funcs.GetAxe() == nil or Bools.Cutter == false or Cut == true
    do
        Funcs.Msg("Done", "Successfully Cut Section")
    end
end
Funcs.TeleportItem = function(item, position, DontFollow, r)
    local counts = 0
    local startpos = Funcs.GetRoot().Position

    for _ = 1, Numbers.Checks do
        if not DontFollow then
            Funcs.Teleport(item.Position + Vector3.new(3, 3, 3))
            task.wait(.3)
        end
        Funcs.GetNetwork(item)
        task.wait(.2)
        Funcs.TeleportPart(item, position, r)
    end
end
Funcs.GetPlot = function(Player)
    for i, v in pairs(game.Workspace.Properties:GetChildren()) do
        if v:FindFirstChild("Owner") and v.Owner.Value and v.Owner.Value.Name == Player.Name then
            return v
        end
    end
    return nil
end
Funcs.HighLight = function(charmodel)
    if not charmodel:FindFirstChildOfClass("Highlight") then
        local hl = Instance.new("Highlight", charmodel)
        hl.FillColor = UnivColors
        hl.DepthMode = "AlwaysOnTop"
        hl.OutlineTransparency = 1
        hl.FillTransparency = Numbers.HlightTransparency / 10
        game.Debris:AddItem(hl, 0.05)
    end
end
Funcs.HighLightGreen = function(model)
    if not model:FindFirstChildOfClass("Highlight") then
        local hl = Instance.new("Highlight", model)
        hl.FillColor = Color3.new(0, 1, 0)
        hl.DepthMode = "AlwaysOnTop"
        hl.OutlineTransparency = 1
        hl.FillTransparency = Numbers.HlightTransparency / 10
    end
end
Funcs.Msg = function(title, text)
    game:GetService("StarterGui"):SetCore("SendNotification", {
        Title = title,
        Text = text or "",
        Duration = 4
    })
end
Funcs.MsgBtn = function(title, text, btntext, func)
    local bindable
    if func then
        bindable = Instance.new("BindableFunction")
        bindable.OnInvoke = function()
            func()
            bindable:Destroy()
        end
    end

    game:GetService("StarterGui"):SetCore("SendNotification", {
        Title = title,
        Text = text,
        Duration = 4,
        Button1 = btntext,
        Callback = bindable
    })
end
Funcs.ShowName = function(charmodel)
    if charmodel and charmodel:FindFirstChild("Head") then
        if charmodel.Head:FindFirstChildOfClass("BillboardGui") then
            return
        end
        local bg = Instance.new("BillboardGui", charmodel.Head)
        local tb = Instance.new("TextBox", bg)
        bg.AlwaysOnTop = true
        bg.StudsOffsetWorldSpace = Vector3.new(0, 1 + Numbers.ESPNameOffset * 2, 0)
        bg.Size = UDim2.fromOffset(100, 50)
        tb.Size = UDim2.fromScale(1, 1)
        tb.BackgroundTransparency = 1
        tb.TextSize = Numbers.ESPNameSize
        tb.ClipsDescendants = false
        tb.TextColor3 = UnivColors
        tb.Text = charmodel.Name .. " [" ..
                      tostring(math.floor((charmodel.Head.Position - Client.Character.Head.Position).Magnitude)) ..
                      " S]"
        game.Debris:AddItem(bg, 0.05)
    end
end
Funcs.RemoveNames = function()
    for _, v in pairs(Funcs.GetService("Players"):GetPlayers()) do
        if v ~= Client and v.Character and v.Character:FindFirstChild("Head") and
            v.Character.Head:FindFirstChildOfClass("BillboardGui") then
            v.Character.Head:FindFirstChildOfClass("BillboardGui"):Destroy()
        end
    end
end
Funcs.RemoveHighlights = function()
    for _, v in pairs(workspace:GetDescendants()) do
        if v:IsA("Highlight") then
            v:Destroy()
        end
    end
end
Funcs.Teleport = function(Position)
    if Client and Client.Character then
        Objects.ControlPart = Funcs.GetRoot()
        Objects.ControlPart.CFrame = CFrame.new(Position)
        Objects.ControlPart.Velocity = Vector3.new(0, 0, 0)
    else
        Funcs.Msg("Error", "No Character/Player")
    end
end
Funcs.AddBind = function(Key, Func)

    Keys[Key] = Func

end
Funcs.AddBindDouble = function(Key, Func, dbtime)
    dbtime = dbtime or 0.3
    Keys[Key] = {
        Func = Func,
        pressed = 0,
        dbtime = dbtime
    }
end
Funcs.AddBindHold = function(Key, Func, Func2)

    Keys[Key] = Func
    UnKeys[Key] = Func2

end
Funcs.FlyToggle = function()

    Bools.CFrameSpeed = false

    Objects.ControlPart = Funcs.GetRoot()
    Bools.Flying = not Bools.Flying

    if Bools.Flying then
        Funcs.Msg("Note", "Enabled Fly")
        local StartPosition = Objects.ControlPart.Position
        Funcs.Teleport(Vector3.new(0, 1000, 0))
        task.wait(.1)

        Objects.ControlPart.Anchored = true
        Funcs.Teleport(StartPosition)
    else
        Funcs.Msg("Note", "Stopped Fly")
        Objects.ControlPart.Anchored = false

    end

end
Funcs.CFrameSpeedToggle = function()
    if not Bools.Flying then
        Bools.CFrameSpeed = not Bools.CFrameSpeed
    end
end
local test = false
Funcs.TeleportPart = function(Part, Position, Raise)
    local finalcf = nil
    if typeof(Position) == "CFrame" then
        finalcf = Position
    else
        finalcf = CFrame.new(Position)
    end
    if Raise then
        finalcf = finalcf + Vector3.new(0, Part.Size.Y / 2, 0)
    end
    if test then
        Part.Parent:PivotTo(finalcf)
    else
        Part.CFrame = finalcf
    end
end
Funcs.StartBuilder = function()
    Bools.Building = true
    local base = Funcs.GetPlot(Client)
    if base == nil then
        Bools.Building = false
        return
    end
    local square = base.OriginSquare
    local spos = square.Position
    Funcs.LandBuildSquare(CFrame.new(spos.X + 40, spos.Y, spos.Z + 80))
    Funcs.LandBuildSquare(CFrame.new(spos.X - 40, spos.Y, spos.Z + 80))
    Funcs.LandBuildSquare(CFrame.new(spos.X + 80, spos.Y, spos.Z + 40))
    Funcs.LandBuildSquare(CFrame.new(spos.X + 80, spos.Y, spos.Z - 40))
    Funcs.LandBuildSquare(CFrame.new(spos.X - 80, spos.Y, spos.Z + 40))
    Funcs.LandBuildSquare(CFrame.new(spos.X - 80, spos.Y, spos.Z - 40))
    Funcs.LandBuildSquare(CFrame.new(spos.X + 40, spos.Y, spos.Z - 80))
    Funcs.LandBuildSquare(CFrame.new(spos.X - 40, spos.Y, spos.Z - 80))
    Funcs.LandBuildSquare(CFrame.new(spos.X + 80, spos.Y, spos.Z + 80))
    Funcs.LandBuildSquare(CFrame.new(spos.X + 80, spos.Y, spos.Z - 80))
    Funcs.LandBuildSquare(CFrame.new(spos.X - 80, spos.Y, spos.Z + 80))
    Funcs.LandBuildSquare(CFrame.new(spos.X - 80, spos.Y, spos.Z - 80))
    Funcs.LandBuildSquare(CFrame.new(spos.X + 40, spos.Y, spos.Z + 40))
    Funcs.LandBuildSquare(CFrame.new(spos.X + 40, spos.Y, spos.Z - 40))
    Funcs.LandBuildSquare(CFrame.new(spos.X - 40, spos.Y, spos.Z + 40))
    Funcs.LandBuildSquare(CFrame.new(spos.X - 40, spos.Y, spos.Z - 40))
    Funcs.LandBuildSquare(CFrame.new(spos.X + 80, spos.Y, spos.Z))
    Funcs.LandBuildSquare(CFrame.new(spos.X - 80, spos.Y, spos.Z))
    Funcs.LandBuildSquare(CFrame.new(spos.X, spos.Y, spos.Z + 80))
    Funcs.LandBuildSquare(CFrame.new(spos.X, spos.Y, spos.Z - 80))
    Funcs.LandBuildSquare(CFrame.new(spos.X + 40, spos.Y, spos.Z))
    Funcs.LandBuildSquare(CFrame.new(spos.X - 40, spos.Y, spos.Z))
    Funcs.LandBuildSquare(CFrame.new(spos.X, spos.Y, spos.Z + 40))
    Funcs.LandBuildSquare(CFrame.new(spos.X, spos.Y, spos.Z - 40))
end
Funcs.StopBuilder = function()
    Bools.Building = false
end
Funcs.SameItem = function(Item1, Item2)
    if Item1:FindFirstChild("TreeClass") and Item2:FindFirstChild("TreeClass") then
        if Item2.TreeClass.Value == Item1.TreeClass.Value then
            return true
        end
    elseif Item1.Name == Item2.Name and Item1.Name ~= "Model" then
        return true
    elseif Item1:FindFirstChild("ItemName") and Item2:FindFirstChild("ItemName") then
        if Item1.ItemName.Value == Item2.ItemName.Value then
            return true
        end
    end
end
Funcs.EasyFurnace = function()
    for _, furnace in pairs(workspace.Stores.WoodRUs:GetChildren()) do
        if furnace.Name == "Furnace" then
            for _, v in pairs(furnace:GetChildren()) do
                if v.Name == "Part" and not v:FindFirstChildOfClass("ParticleEmitter") then
                    v.CanCollide = not v.CanCollide
                    if not v.CanCollide then
                        v.Transparency = 1
                    else
                        v.Transparency = 0
                    end
                end
            end
        end
    end
end
Funcs.Lava = function(Section)
    Funcs.TeleportItem(Section, Vector3.new(-1800.2, 261, 1220.4))
    Funcs.Teleport(Vector3.new(-1818.3, 270.5, 1228.7))
    Bools.FakeFreeze = true
    Objects.FreezeCF = Funcs.GetRoot().CFrame
    task.wait(.2)
    Section.Parent:PivotTo(CFrame.new(Funcs.GetPlot(Client).OriginSquare.Position + Vector3.new(0, 5, 0)))
    Bools.FakeFreeze = false
    Funcs.GotoPlot()
end
Funcs.GetAllTrees = function(MinimumSections, TreeClass)
    local trees = {}
    for _, Region in ipairs(workspace:GetChildren()) do
        if Region.Name == "TreeRegion" then
            for _, Tree in ipairs(Region:GetChildren()) do
                local Sections = 0
                for _, Section in pairs(Tree:GetChildren()) do
                    if Section.Name == "WoodSection" then
                        Sections = Sections + 1
                    end
                end
                if Tree:FindFirstChild("TreeClass") and Sections >= (MinimumSections or 1) then
                    if TreeClass then
                        if Tree.TreeClass.Value == TreeClass then
                            table.insert(trees, Tree)
                        end
                    end
                end
            end
        end
    end
    return trees
end
Funcs.GetTreeUnits = function(Tree)
    local TreeUnits = 0
    for _, Section in pairs(Tree:GetChildren()) do
        if Section.Name == "WoodSection" then
            local Units = Section.Size.X * Section.Size.Y * Section.Size.Z
            TreeUnits = TreeUnits + Units
        end
    end
    return TreeUnits
end
Funcs.FindTree = function(TreeClass, OnlyBiggest)
    Objects.ChosenTree = TreeClass
    local trees = Funcs.GetAllTrees(2, TreeClass)
    if trees[1] ~= nil then
        if OnlyBiggest then
            local Units = 0
            local BestTree = nil
            for _, Tree in pairs(trees) do
                local TreeUnits = Funcs.GetTreeUnits(Tree)
                if TreeUnits > Units then
                    Units = TreeUnits
                    BestTree = Tree
                end
            end
            if BestTree then
                Funcs.Teleport(BestTree:GetPivot().Position + Vector3.new(3, 2, 3))
                Funcs.Msg("Finder", "Tree Found.")
                return
            end
        else
            Funcs.Teleport(trees[math.random(1, #trees)]:GetPivot().Position + Vector3.new(3, 2, 3))
            Funcs.Msg("Finder", "Tree Found.")
            Objects.ChosenTree = TreeClass
            return
        end
    end
    Funcs.Msg("Finder", "No Tree / Too Small")
end
Funcs.TreeExists = function(Class)
    for i, v in ipairs(workspace:GetChildren()) do
        if v.Name == "TreeRegion" then
            for j, k in ipairs(v:GetChildren()) do
                local ws = 0
                for _, v in pairs(k:GetChildren()) do
                    if v.Name == "WoodSection" then
                        ws = ws + 1
                    end
                end
                if k:FindFirstChild("TreeClass") ~= nil and k.TreeClass.Value == Class and ws >= 1 then
                    return k
                end
            end
        end
    end
end
Funcs.GetTrunk = function(Tree)
    for _, v in pairs(Tree:GetChildren()) do
        if v.Name == "WoodSection" and v.ID.Value == 1 then
            return v
        end
    end
    return nil
end
Funcs.AddTreeToFinder = function(Tab, Display, TreeClass, Price, Abundance)

    WoodPrices[TreeClass] = Price
    MyPrices[TreeClass] = Price + (Numbers.ExtraPricePlanks / Abundance)

    Tab:Button(string.upper(Display), function()
        Funcs.FindTree(TreeClass)
    end)
end
Funcs.EyeAssist = function()
    if workspace:FindFirstChild("ASSISTPART") then
        workspace.ASSISTPART:Destroy()
        return
    end
    local newpart = Instance.new("Part", workspace)
    newpart.Name = "ASSISTPART"
    newpart.CFrame = CFrame.new(135.4, 5.5, -608.27)
    newpart.Size = Vector3.new(3, 1.2, 3)
    newpart.Transparency = 0
    newpart.Color = Color3.new(1, 1, 1)
    newpart.Orientation = Vector3.new(90, 0, 90)
    newpart.Anchored = true
end

-- // Init

for a, b in pairs(workspace:GetChildren()) do
    if b.name == "TreeRegion" then
        b.ChildAdded:Connect(function(NewTree)
            table.insert(Tables.TreeList, NewTree)
        end)
        for c, d in pairs(b:GetChildren()) do
            if d.Name == "Model" then
                table.insert(Tables.TreeList, d)
            end
        end
    end
end
Funcs.GetUnitInfo = function(WoodSection)
    local Class = WoodSection.Parent.TreeClass.Value
    local Height = WoodSection.Size.Y * Numbers.MaxDigits / Numbers.MaxDigits
    local Units = WoodSection.Size.X * WoodSection.Size.Y * WoodSection.Size.Z

    local Price = MyPrices[Class] * Units
    local DropPrice = WoodPrices[Class] * Units

    Funcs.Msg("Plank Info", "Length: " .. tostring(Funcs.Format(Height, Numbers.MaxDigits)) .. ", Units: " ..
        tostring(Funcs.Format(Units, Numbers.MaxDigits)))
    Funcs.Msg("My Price", tostring(Funcs.Format(Price, Numbers.MaxDigits)))
    Funcs.Msg("DropOff Price", tostring(Funcs.Format(DropPrice, Numbers.MaxDigits)))
end
Funcs.GetTreeLength = function(WoodSection)
    local fullheight = 0
    for _, v in pairs(WoodSection.Parent:GetChildren()) do
        if v.Name == "WoodSection" then
            fullheight = fullheight + v.Size.Y
        end
    end
    local Height = Funcs.Format(fullheight, Numbers.MaxDigits)
    Funcs.Msg("Tree Length Grabber", "Tree Length Is " .. tostring(Height))
end

local Toggles = {}

Toggles.BlueprintFiller = function()
    Bools.BPFiller = not Bools.BPFiller
    if Bools.BPFiller then
        Objects.SelectedBP = nil
        Funcs.Msg("Note", "Enabled Filler")
    else
        Funcs.Msg("Note", "Disabled Filler")
    end
end
Toggles.Seller = function()
    if Bools.SellEnabled then
        Bools.SellEnabled = false
        Funcs.Msg("Disabled Seller", "yes")
        return
    end
    Bools.SellEnabled = true
    Funcs.Msg("Enabled Seller", "Press F on an Item")
end
Toggles.ClickTp = function()
    if Bools.ClickTP then
        Bools.ClickTP = false
        Funcs.Msg("Disabled ClickTp", "yes")
        return
    end
    Bools.ClickTP = true
    Funcs.Msg("Enabled ClickTp", "Start clickin'")
end
Toggles.Cutter = function()
    if Funcs.GetAxe() ~= nil then
        Bools.Cutter = not Bools.Cutter
        if Bools.Cutter then
            Funcs.Msg("Enabled Cutter", "Get To Choppin'")
        else
            Funcs.Msg("Disabled Cutter", "yes")
        end
    else
        Funcs.Msg("Error", "No Axe")
        Bools.Cutter = false
    end
end
